Избегайте неявного линейного поиска
> В этом примере метод Any использует алгоритм линейного поиска, чтобы проверить, что указанный идентификатор находится в коллекции.
> Разработчикам не обязательно знать, как реализован каждый из методов LINQ. Важно знать основы: в .NET коллекция List<T> базируется на массиве. 
> А когда дело доходит до поиска значения в несортированном массиве, его сложность составляет O(n). 
> Независимо от того, какой метод LINQ используется для поиска значения в массиве (Any, Contains или Where), сложность остается прежней.
> Решением этой конкретной проблемы было бы использование структуры данных, подходящей для конкретной задачи. 
> В нашем случае у нас есть идентификаторы, которые всегда уникальны. Это позволяет нам преобразовать коллекцию в 
  
```csharp
public void LinearSearchTest()
{
  var ids = Enumerable.Range(0, 10000000);
  int idToFind = 9193513;
  var exists = ids.Any(u => u == idToFind);
}
```
```csharp
HashSet<T>.
public void HashSetTest()
{
  var ids = Enumerable.Range(0, 10000000).ToHashSet();
  int idToFind = 9193513;
  var exists = ids.Contains(idToFind);
}
```
|           Method |      Mean |
|----------------- |----------:|
| LinearSearchTest |  63.74 ms |
|      HashSetTest | 334.34 ms |

> Разработчики выиграют от преобразования в HashSet только в том случае, если они планируют часто вызывать на коллекции метод Contains. 
> Если вынести создание коллекции из тестов производительности и измерить только время нахождения элемента, результаты будут кардинально отличаться.
> Поиск значения в HashSet<T> почти не занимает времени по сравнению с поиском значения в коллекции List<T>.
