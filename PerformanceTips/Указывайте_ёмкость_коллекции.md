> Рассмотрим два почти идентичных метода:
```csharp
public void NonFixedCapacityTest()
{
  var items = new List<decimal>();
  for (int i = 0; i < 1000000; i++)
    items.Add(i);
}

public void FixedCapacityTest()
{
  const int capacity = 1000000;
  var items = new List<decimal>(capacity);
  for (int i = 0; i < capacity; i++)
    items.Add(i);
}
```

> Оба метода выполняют одну и ту же задачу - заполнение коллекции целыми числами с помощью цикла foreach. 
> Единственное отличие состоит в том, что в методе FixedCapacityTest конструктор коллекции инициализируется некоторым числом. 
> Этот простой трюк заставляет метод FixedCapacityTest работать в два раза быстрее, чем NonFixedCapacityTest.

|               Method |      Mean |
|--------------------- |----------:|
| NonFixedCapacityTest | 22.708 ms |
|    FixedCapacityTest |  8.418 ms |
> Производительность в два-три раза выше, потому что List<T> реализован таким образом, что хранит элементы в массиве, который представляет собой структуру данных фиксированного размера. Когда разработчик создает экземпляр List<T> без указания его ёмкости, выделяется массив ёмкости по умолчанию.
> Когда массив заполнен, выделяется новый массив большего размера, а значения из старого массива копируются в новый.
> Предварительное указание ёмкости устраняет накладные расходы на выделение, копирование и сборку мусора использованных массивов. Разработчики должны всегда указывать ёмкость коллекции, если они заранее знают, сколько элементов будет в неё добавлено.
> Параметр ёмкости работает не только с коллекцией List, но и с другими, такими как Dictionary<TKey, TValue>, HashSet<T> и т.п.
