> Часто бывает необходимо перебрать коллекцию с помощью цикла foreach и выполнить некоторую логику для каждого элемента.

```csharp
public void ForeachTest()
{
  var items = Enumerable.Range(0, 100).ToList();
  foreach (var item in items)
  {
    //Симулируем длинную операцию
    Thread.Sleep(1);
  }
}
```

> В этом примере итерации выполняются одна за другой в одном и том же потоке, поэтому общее время выполнения будет линейно расти с размером коллекции.
> Производительность можно повысить, начав использовать параллельную версию цикла foreach, которую платформа предоставляет разработчикам.

```csharp
public void ParallelForeachTest()
{
  var items = Enumerable.Range(0, 100).ToList();

  Parallel.ForEach(items, (item) =>
  {
    //Симулируем длинную операцию
    Thread.Sleep(1);
  });
}
```
> **Parallel.Foreach** можно использовать на любой коллекции, которая реализует IEnumerable<T> как обычный цикл foreach. Реализация Parallel.Foreach выполнит всю работу по распараллеливанию за вас:
> - разобьёт коллекцию на части,
> - назначит и выполнит эти части в отдельных потоках.

|              Method |       Mean |
|-------------------- |-----------:|
|         ForeachTest | 1,543.9 ms |
| ParallelForeachTest |   199.9 ms |
> Надо отметить, что если коллекции небольшие и время выполнения одной итерации быстрое,
> переход с foreach на Parallel.Foreach может даже ухудшить производительность, особенно если используется синхронизация потоков из-за доступа к общим ресурсам.
> Функциональные возможности, предоставляемые классом Parallel, являются отличным выбором для длительных итераций, 
> которые не зависят друг от друга и не требуют использования примитивов синхронизации, таких как потокобезопасные коллекции.
